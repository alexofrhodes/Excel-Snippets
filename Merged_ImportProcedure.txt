''''''''''''''''''''''''''''''
'Contains the following #16 procedures 
''''''''''''''''''''''''''''''
'ActiveCodepaneWorkbook
'CheckPath
'CodepaneSelection
'CreateOrSetModule
'DownloadTextFile
'FileExists
'FolderExists
'HttpExists
'ImportImports
'ImportProcedure
'ModuleOfProcedure
'ProcedureExists
'ProceduresOfWorkbook
'TxtOverwrite
'TxtRead
'UpdateProcedure
'


Sub ImportProcedure( _
    Optional PROCEDURE As String, _
    Optional TargetWorkbook As Workbook, _
    Optional Module As VBComponent, _
    Optional OverWrite As Boolean)

'#INCLUDE DownloadTextFile
'#INCLUDE CheckPath
'#INCLUDE CodepaneSelection
'#INCLUDE TxtOverwrite
'#INCLUDE ImportImports
'#INCLUDE UpdateProcedure
'#INCLUDE TxtRead
'#INCLUDE ProcedureExists
'#INCLUDE ActiveCodepaneWorkbook
'#INCLUDE CreateOrSetModule
    
    
''''''''''''''''''''''''''''''''''''''''''''
''DEVELOPER  Anastasiou Alex
''EMAIL      AnastasiouAlex@gmail.com
''GITHUB     https://github.com/AlexOfRhodes
''YOUTUBE    https://bit.ly/3aLZU9M
''''''''''''''''''''''''''''''''''''''''''''

    Rem @todo file picker?
    
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If PROCEDURE = "" Then PROCEDURE = CodepaneSelection
    
    If PROCEDURE = "" Or InStr(1, PROCEDURE, " ") > 0 Then Exit Sub
    Dim ProcedurePath As String
    ProcedurePath = SNIP_FOLDER & PROCEDURE & ".txt"
    
    If CheckPath(ProcedurePath) = "I" Then
        On Error Resume Next
        Dim DownloadedProcedure As String
        DownloadedProcedure = DownloadTextFile("https://github.com/alexofrhodes/Excel-Snippets/raw/main/" & PROCEDURE & ".txt")
        On Error GoTo 0
        If Len(DownloadedProcedure) > 0 Then
            TxtOverwrite SNIP_FOLDER & PROCEDURE & ".txt", DownloadedProcedure
        Else
            MsgBox "File not found neither localy nor online"
            Exit Sub
        End If
    End If
    
    If ProcedureExists(PROCEDURE, TargetWorkbook) = True Then
        If OverWrite = True Then UpdateProcedure PROCEDURE, TxtRead(ProcedurePath), TargetWorkbook
    Else
        If Module Is Nothing Then Set Module = CreateOrSetModule("vbArcImports", vbext_ct_StdModule, TargetWorkbook)
        Module.CodeModule.AddFromFile ProcedurePath
    End If
    ImportImports ProcedurePath, TargetWorkbook, Module, OverWrite
End Sub

Function DownloadTextFile(URL As String) As String
    On Error GoTo Err_GetFromWebpage
    Dim objWeb As Object
    Dim strXML As String
    Set objWeb = CreateObject("Msxml2.ServerXMLHTTP")
    objWeb.Open "GET", URL, False
    objWeb.setRequestHeader "Content-Type", "text/xml"
    objWeb.setRequestHeader "Cache-Control", "no-cache"
    objWeb.setRequestHeader "Pragma", "no-cache"
    objWeb.send
    strXML = objWeb.responseText
    DownloadTextFile = strXML
End_GetFromWebpage:
    Set objWeb = Nothing
    Exit Function
Err_GetFromWebpage:
    MsgBox err.Description & " (" & err.Number & ")"
    Resume End_GetFromWebpage
End Function


Function CheckPath(path) As String
    Dim retval
    retval = "I"
    If (retval = "I") And FileExists(path) Then retval = "F"
    If (retval = "I") And FolderExists(path) Then retval = "D"
    If (retval = "I") And HttpExists(path) Then retval = "U"
    CheckPath = retval
End Function

Public Function CodepaneSelection() As String
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    If EndLine - StartLine = 0 Then
        CodepaneSelection = Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(StartLine, 1), StartColumn, EndColumn - StartColumn)
        Exit Function
    End If
    Dim str As String
    Dim i As Long
    For i = StartLine To EndLine
        If str = "" Then
            str = Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), StartColumn)
        ElseIf i < EndLine Then
            str = str & vbNewLine & Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), 1)
        Else
            str = str & vbNewLine & Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), 1, EndColumn - 1)
        End If
    Next
    CodepaneSelection = str
End Function

Function TxtOverwrite(sFile As String, sText As String)
    On Error GoTo Err_Handler
    Dim FileNumber As Integer
    FileNumber = FreeFile
    Open sFile For Output As #FileNumber
    Print #FileNumber, sText
    Close #FileNumber
Exit_Err_Handler:
    Exit Function
Err_Handler:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & err.Number & vbCrLf & _
           "Error Source: TxtOverwrite" & vbCrLf & _
           "Error Description: " & err.Description, vbCritical, "An Error has Occurred!"
    GoTo Exit_Err_Handler
End Function

Sub ImportImports( _
    Optional PROCEDURE As String, _
    Optional TargetWorkbook As Workbook, _
    Optional Module As VBComponent, _
    Optional OverWrite As Boolean)
    
    Rem @TODO infinite loop possible?
    Dim var
    Dim importfile As String
    var = Split(TxtRead(PROCEDURE), vbLf)
    Dim TextLine As Variant
    For Each TextLine In var
        TextLine = Trim(TextLine)
        If Left(TextLine, 9) = "'#INCLUDE" Then
            importfile = Split(TextLine, " ")(1)
            ImportProcedure importfile, TargetWorkbook, Module, OverWrite
        End If
    Next
End Sub

Public Sub UpdateProcedure( _
                            PROCEDURE As Variant, _
                            Code As String, _
                            TargetWorkbook As Workbook)
    Dim StartLine As Integer
    Dim NumLines As Integer
    Dim Module As VBComponent
    Set Module = ModuleOfProcedure(TargetWorkbook, PROCEDURE)
    With Module.CodeModule
        StartLine = .ProcStartLine(PROCEDURE, vbext_pk_Proc)
        NumLines = .ProcCountLines(PROCEDURE, vbext_pk_Proc)
        .DeleteLines StartLine, NumLines
        .InsertLines StartLine, Code
    End With
End Sub

Function TxtRead(sPath As String) As String
'#INCLUDE FileExists
    If FileExists(sPath) = False Then
        MsgBox "File was not found."
        Exit Function
    End If
    Open sPath For Input As #1
    Do Until EOF(1)
        Line Input #1, sTXT
        TxtRead = TxtRead & sTXT & vbLf
    Loop
    Close
    If Len(TxtRead) = 0 Then
        TxtRead = ""
    Else
        TxtRead = Left(TxtRead, Len(TxtRead) - 1)
    End If
End Function



Function ProcedureExists( _
         PROCEDURENAME As Variant, _
         FromWorkbook As Workbook) _
        As Boolean
'#INCLUDE ProceduresOfWorkbook
    Dim AllProcedures As Collection: Set AllProcedures = ProceduresOfWorkbook(FromWorkbook)
    Dim PROCEDURE As Variant
    For Each PROCEDURE In AllProcedures
        If UCase(CStr(PROCEDURE)) = UCase(PROCEDURENAME) Then
            ProcedureExists = True
            Exit Function
        End If
    Next
End Function

Public Function ActiveCodepaneWorkbook() As Workbook
    Dim TmpStr As String
    TmpStr = Application.VBE.SelectedVBComponent.Collection.Parent.FileName
    TmpStr = Right(TmpStr, Len(TmpStr) - InStrRev(TmpStr, "\"))
    Set ActiveCodepaneWorkbook = Workbooks(TmpStr)
End Function

Function CreateOrSetModule(compName As String, compType As VBIDE.vbext_ComponentType, Optional TargetWorkbook As Workbook) As VBComponent
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim vbComp As VBComponent
    On Error Resume Next
    Set vbComp = TargetWorkbook.VBProject.VBComponents(compName)
    On Error GoTo 0
    If vbComp Is Nothing Then
        Set vbComp = TargetWorkbook.VBProject.VBComponents.Add(compType)
        vbComp.Name = compName
    End If
    Set CreateOrSetModule = vbComp
End Function

Function ModuleOfProcedure(wb As Workbook, PROCEDURENAME As Variant) As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long, NumProc As Long
    Dim procname As String
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        With vbComp.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines
                procname = .ProcOfLine(lineNum, ProcKind)
                lineNum = .ProcStartLine(procname, ProcKind) + .ProcCountLines(procname, ProcKind) + 1
                If UCase(procname) = UCase(PROCEDURENAME) Then
                    Set ModuleOfProcedure = vbComp
                    Exit Function
                End If
            Loop
        End With
    Next vbComp
End Function

Function FileExists(ByVal strFile As String, Optional bFindFolders As Boolean) As Boolean
    Dim lngAttributes As Long
    lngAttributes = (vbReadOnly Or vbHidden Or vbSystem)
    If bFindFolders Then
        lngAttributes = (lngAttributes Or vbDirectory)
    Else
        Do While Right$(strFile, 1) = "\"
            strFile = Left$(strFile, Len(strFile) - 1)
        Loop
    End If
    On Error Resume Next
    FileExists = (Len(Dir(strFile, lngAttributes)) > 0)
End Function

Function FolderExists(ByVal strPath As String) As Boolean
    On Error Resume Next
    FolderExists = ((GetAttr(strPath) And vbDirectory) = vbDirectory)
End Function

Function HttpExists(ByVal sURL As String) As Boolean
    Dim oXHTTP As Object
    Set oXHTTP = CreateObject("MSXML2.XMLHTTP")
    If Not UCase(sURL) Like "HTTP:*" Then
        sURL = "http://" & sURL
    End If
    On Error GoTo haveError
    oXHTTP.Open "HEAD", sURL, False
    oXHTTP.send
    HttpExists = IIf(oXHTTP.Status = 200, True, False)
    Exit Function
haveError:
    Rem Debug.Print err.Description
    HttpExists = False
End Function



Function ProceduresOfWorkbook(TargetWorkbook As Workbook) As Collection
    Dim Module As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long
    Dim coll As New Collection
    Dim PROCEDURENAME As String
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If Module.Type <> vbext_ct_ClassModule Then
            With Module.CodeModule
                lineNum = .CountOfDeclarationLines + 1
                Do Until lineNum >= .CountOfLines
                    PROCEDURENAME = .ProcOfLine(lineNum, ProcKind)
                    If InStr(1, PROCEDURENAME, "_") = 0 Then coll.Add PROCEDURENAME
                    lineNum = .ProcStartLine(PROCEDURENAME, ProcKind) + .ProcCountLines(PROCEDURENAME, ProcKind) + 1
                Loop
            End With
        End If
    Next
    Set ProceduresOfWorkbook = coll
End Function
