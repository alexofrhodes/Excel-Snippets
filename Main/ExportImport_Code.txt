
''DEVELOPER  Anastasiou Alex
''EMAIL      AnastasiouAlex@gmail.com
''GITHUB     https://github.com/AlexOfRhodes
''YOUTUBE    https://bit.ly/3aLZU9M
''VK         https://vk.com/vbarc_hive
''FACEBOOK   https://www.facebook.com/profile.php?id=100065068627996

''Please keep the comments

'You can copy this txt to a module in your Personal.xlsb to have it work for all your projects using the immediate window,
'or  make a vbe [commandbar](https://github.com/alexofrhodes/vba-Multiple-Commandbars-from-sheet-data),
'or a popup Macro menu with [autohotkey](https://github.com/alexofrhodes/AutoHotkey/tree/main/Excel%20macro%20menu/popup%20variant)

'Contact me for more help, suggestions, bug reports or just to say hi.



'Change the following lines to your existing PC and GITHUB Folders

Public Const SNIP_FOLDER = "C:\Users\acer\Documents\vbArc\SNIPPETS\"                                        'with \ at end
Public Const GITHUB_FOLDER = "https://raw.githubusercontent.com/alexofrhodes/Snippets/main/Procedures/"     'with / at end

'+++ TEST +++
Sub TestExport()
    ExportProcedure "ExportProcedure"
End Sub

Sub TestImport()
    ImportProcedure "WhichOption"
End Sub

'===MAIN PROCEDURES===

'ExportProcedure  (place mouse inside procedure's code or select a procedure name to call without passing arguments)
'ImportProcedure  (select a procedure name to call without passing arguments)
'getMissingMissingDependenciesOfProcedure    (place mouse inside procedure's code to call without passing arguments)
'UpdateAllProcedures


'Example use from immediate window:
'----------------------------------
'exportprocedure "exportprocedure"
'importprocedure "WhichOption"       'case sensitive when getting file from github repo


Sub ExportProcedure( _
                        Optional PROCEDURENAME As String, _
                        Optional FromWorkbook As Workbook)
'#INCLUDE FollowLink
'#INCLUDE FileExists
'#INCLUDE AddListOfLinkedProceduresToProcedure
'#INCLUDE TxtOverwrite
'#INCLUDE ExportProcedure
'#INCLUDE LinkedProcs
'#INCLUDE TxtRead
'#INCLUDE ProceduresOfWorkbook
'#INCLUDE ProcedureExists
'#INCLUDE ActiveCodepaneWorkbook
'#INCLUDE ActiveProcedure
'#INCLUDE ListContainedProceduresInTXT
'#INCLUDE dp
'#INCLUDE CollectionContains
'#INCLUDE ExportTargetProcedure



    'SNIP_FOLDER = Environ("USERprofile") & "\My Documents\vbArc\Snippets\"
    'If FolderExists(SNIP_FOLDER) = False Then FoldersCreate (SNIP_FOLDER)

    If PROCEDURENAME = "" Then PROCEDURENAME = ActiveProcedure
    If FromWorkbook Is Nothing Then Set FromWorkbook = ActiveCodepaneWorkbook
    

    If ProcedureExists(PROCEDURENAME, FromWorkbook) = False Then
        MsgBox PROCEDURENAME & " not found in workbook " & FromWorkbook.Name
    End If
    
    AddListOfLinkedProceduresToProcedure CStr(PROCEDURENAME), ProceduresOfWorkbook(FromWorkbook), FromWorkbook
    
    Dim ExportedProcedures As New Collection
    Dim Proccessed As New Collection
    
    On Error Resume Next
    
    ExportTargetProcedure PROCEDURENAME
    ExportedProcedures.Add CStr(PROCEDURENAME), CStr(PROCEDURENAME)
    
    For Each PROCEDURE In LinkedProcs(PROCEDURENAME, FromWorkbook)
        AddListOfLinkedProceduresToProcedure CStr(PROCEDURE), ProceduresOfWorkbook(FromWorkbook), FromWorkbook
        ExportTargetProcedure CStr(PROCEDURE), FromWorkbook
        ExportedProcedures.Add CStr(PROCEDURE), CStr(PROCEDURE)
    Next
    
    'test
    Dim ProceduresCount As Long
    ProceduresCount = ExportedProcedures.Count
retry:
    For Each PROCEDURE In ExportedProcedures
        For Each ELEMENT In LinkedProcs(PROCEDURE, FromWorkbook)
            If Not CollectionContains(ExportedProcedures, , ELEMENT) Then
                AddListOfLinkedProceduresToProcedure CStr(ELEMENT), ProceduresOfWorkbook(FromWorkbook), FromWorkbook
                ExportedProcedures.Add CStr(ELEMENT), CStr(ELEMENT)
            End If
        Next
    Next
    If ExportedProcedures.Count > ProceduresCount Then
        ProceduresCount = ExportedProcedures.Count
        GoTo retry
    End If
    On Error GoTo 0
    'end test
            
        If ExportedProcedures.Count > 1 Then
            Dim MergedName As String
            Dim procFile As String
                MergedName = "Merged_" & PROCEDURENAME
                Dim MergedString As String
                For Each PROCEDURE In ExportedProcedures
                    procFile = SNIP_FOLDER & CStr(PROCEDURE) & ".txt"
                    MergedString = IIf(MergedString = "", TxtRead(procFile), MergedString & vbNewLine & TxtRead(procFile))
                Next
                TxtOverwrite SNIP_FOLDER & MergedName & ".txt", MergedString
                ListContainedProceduresInTXT SNIP_FOLDER & MergedName & ".txt"
        End If
        FollowLink SNIP_FOLDER
End Sub


Sub ImportProcedure( _
    Optional PROCEDURE As String, _
    Optional TargetWorkbook As Workbook, _
    Optional Module As VBComponent, _
    Optional OverWrite As Boolean)
'#INCLUDE FolderExists
'#INCLUDE FoldersCreate

'#INCLUDE DownloadTextFile
'#INCLUDE CheckPath
'#INCLUDE CodepaneSelection
'#INCLUDE TxtOverwrite
'#INCLUDE ImportImports
'#INCLUDE UpdateProcedure
'#INCLUDE TxtRead
'#INCLUDE ProcedureExists
'#INCLUDE ActiveCodepaneWorkbook
'#INCLUDE CreateOrSetModule
    
    
''''''''''''''''''''''''''''''''''''''''''''
''DEVELOPER  Anastasiou Alex
''EMAIL      AnastasiouAlex@gmail.com
''GITHUB     https://github.com/AlexOfRhodes
''YOUTUBE    https://bit.ly/3aLZU9M
''''''''''''''''''''''''''''''''''''''''''''

    'SNIP_FOLDER = Environ("USERprofile") & "\My Documents\vbArc\Snippets\"
    'If FolderExists(SNIP_FOLDER) = False Then FoldersCreate (SNIP_FOLDER)

    Rem @todo file picker?
    
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If PROCEDURE = "" Then PROCEDURE = CodepaneSelection
    
    If PROCEDURE = "" Or InStr(1, PROCEDURE, " ") > 0 Then Exit Sub
    Dim ProcedurePath As String
    ProcedurePath = SNIP_FOLDER & PROCEDURE & ".txt"
    
    If CheckPath(ProcedurePath) = "I" Then
        'On Error Resume Next
        Dim DownloadedProcedure As String
        DownloadedProcedure = DownloadTextFile(GITHUB_FOLDER & PROCEDURE & ".txt")
        'On Error GoTo 0
        If InStr(1, DownloadedProcedure, "</html>") = 0 And InStr(1, DownloadedProcedure, "Not Found") = 0 Then
            TxtOverwrite SNIP_FOLDER & PROCEDURE & ".txt", DownloadedProcedure
        Else
            MsgBox "File not found neither localy nor online." & vbNewLine & _
            "Remember that searching github for a procedure is case sensitive"
            Exit Sub
        End If
    End If
    
    If ProcedureExists(PROCEDURE, TargetWorkbook) = True Then
        If OverWrite = True Then UpdateProcedure PROCEDURE, TxtRead(ProcedurePath), TargetWorkbook
    Else
        Set Module = CreateOrSetModule("vbArcImports", vbext_ct_StdModule, TargetWorkbook)
        Module.CodeModule.AddFromFile ProcedurePath
    End If
    ImportImports ProcedurePath, TargetWorkbook, Module, OverWrite
End Sub

Public Function getAllMissingDependencies(Optional TargetWorkbook As Workbook) As Boolean
'#INCLUDE ProceduresOfWorkbook
'#INCLUDE ActiveCodepaneWorkbook
'#INCLUDE getMissingMissingDependenciesOfProcedure
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim procedures As New Collection
    Set procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim PROCEDURE As Variant
    For Each PROCEDURE In procedures
        getMissingMissingDependenciesOfProcedure CStr(PROCEDURE), TargetWorkbook
    Next
End Function

Public Function getMissingMissingDependenciesOfProcedure(Optional PROCEDURE As String, Optional TargetWorkbook As Workbook) As Boolean
'#INCLUDE ImportProcedure
'#INCLUDE ProceduresOfWorkbook
'#INCLUDE ActiveCodepaneWorkbook
'#INCLUDE ActiveProcedure
'#INCLUDE GetProcText
'#INCLUDE ModuleOfProcedure
'#INCLUDE CollectionContains
    If PROCEDURE = "" Then PROCEDURE = ActiveProcedure
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim procedures As New Collection
    Set procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Code As String
        Code = GetProcText(ModuleOfProcedure(TargetWorkbook, PROCEDURE), PROCEDURE)
    Dim CodeLines As Variant
        CodeLines = Split(ProcedureCode, vbNewLine)
    Dim CodeLine As Variant
    Dim RequiredProcedure As String
    Dim Log As String
    If InStr(1, Code, "'#INCLUDE", vbTextCompare) > 0 Then
        For Each CodeLine In CodeLines
            If Left(CodeLine, 9) = "'#INCLUDE" Then
                RequiredProcedure = Split(CodeLine, " ")(1)
                If Not CollectionContains(procedures, , RequiredProcedure) Then
                    ImportProcedure RequiredProcedure, TargetWorkbook, , True
                    'If Log = "" Then Log = TargetWorkbook.Name & " is missing the following required procedures in order to run : " & PROCEDURE
                    'Log = Log & vbNewLine & RequiredProcedure
                End If
            End If
        Next
    End If
    'Debug.Print IIf(Log <> "", Log, TargetWorkbook.Name & " contains all requires Procedures to run : " & PROCEDURE)
    ProcedureDependenciesExist = (Log = "")
End Function

Sub UpdateAllProcedures(Optional TargetWorkbook As Workbook)
If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim procedures As New Collection
    Set procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim PROCEDURE
    For Each PROCEDURE In procedures
        If UCase(CStr(PROCEDURE)) <> UCase("UpdateAllProcedures") Then ImportProcedure CStr(PROCEDURE), TargetWorkbook, , True
    Next
End Sub


'---HELPER FUNCTIONS---

Private Function DownloadTextFile(URL As String) As String
    On Error GoTo Err_GetFromWebpage
    Dim objWeb As Object
    Dim strXML As String
    Set objWeb = CreateObject("Msxml2.ServerXMLHTTP")
    objWeb.Open "GET", URL, False
    objWeb.setRequestHeader "Content-Type", "text/xml"
    objWeb.setRequestHeader "Cache-Control", "no-cache"
    objWeb.setRequestHeader "Pragma", "no-cache"
    objWeb.send
    strXML = objWeb.responseText
    DownloadTextFile = strXML
End_GetFromWebpage:
    Set objWeb = Nothing
    Exit Function
Err_GetFromWebpage:
    MsgBox Err.Description & " (" & Err.Number & ")"
    Resume End_GetFromWebpage
End Function

Private Function FileExists(ByVal strFile As String, Optional bFindFolders As Boolean) As Boolean
    Dim lngAttributes As Long
    lngAttributes = (vbReadOnly Or vbHidden Or vbSystem)
    If bFindFolders Then
        lngAttributes = (lngAttributes Or vbDirectory)
    Else
        Do While Right$(strFile, 1) = "\"
            strFile = Left$(strFile, Len(strFile) - 1)
        Loop
    End If
    On Error Resume Next
    FileExists = (Len(Dir(strFile, lngAttributes)) > 0)
End Function


Private Sub AddListOfLinkedProceduresToProcedure(PROCEDURENAME As String, procedures As Collection, FromWorkbook As Workbook)
'#INCLUDE RegexTest
'#INCLUDE ProcedureFirstLine
'#INCLUDE GetProcText
'#INCLUDE ModuleOfProcedure
    
    Dim ListOfImports As String
    Dim Module As VBComponent:  Set Module = ModuleOfProcedure(FromWorkbook, PROCEDURENAME)
    Dim ProcedureText As String:    ProcedureText = GetProcText(Module, PROCEDURENAME)
    Dim PROCEDURE As Variant
    For Each PROCEDURE In procedures
        If UCase(CStr(PROCEDURE)) <> UCase(CStr(PROCEDURENAME)) Then
Rem         If InStr(1, ProcedureText, CStr(PROCEDURE)) > 0 Then
            If RegexTest(ProcedureText, "\W" & PROCEDURE & "[.(\W]", , True) = True Then
                If InStr(1, ProcedureText, "#INCLUDE " & PROCEDURE) = 0 And InStr(1, ListOfImports, "#INCLUDE " & PROCEDURE) = 0 Then
                    If ListOfImports = "" Then
                        ListOfImports = "'#INCLUDE " & PROCEDURE
                    Else
                        ListOfImports = ListOfImports & vbNewLine & "'#INCLUDE " & PROCEDURE
                    End If
                End If
                
            End If
        End If
    Next
    If ListOfImports <> "" Then Module.CodeModule.InsertLines ProcedureFirstLine(Module, PROCEDURENAME), ListOfImports
End Sub

Private Function TxtOverwrite(sFile As String, sText As String)
    On Error GoTo Err_Handler
    Dim FileNumber As Integer
    FileNumber = FreeFile
    Open sFile For Output As #FileNumber
    Print #FileNumber, sText
    Close #FileNumber
Exit_Err_Handler:
    Exit Function
Err_Handler:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & Err.Number & vbCrLf & _
           "Error Source: TxtOverwrite" & vbCrLf & _
           "Error Description: " & Err.Description, vbCritical, "An Error has Occurred!"
    GoTo Exit_Err_Handler
End Function

Private Sub ExportTargetProcedure( _
                    Optional PROCEDURENAME As String, _
                    Optional FromWorkbook As Workbook)
'#INCLUDE FileExists
'#INCLUDE TxtOverwrite
'#INCLUDE LinkedProcs
'#INCLUDE ActiveCodepaneWorkbook
'#INCLUDE ActiveProcedure
'#INCLUDE GetProcText
'#INCLUDE ModuleOfProcedure
'#INCLUDE FileLastModified
'#INCLUDE dp
    
    
    
    If PROCEDURENAME = "" Then PROCEDURENAME = ActiveProcedure
    If FromWorkbook Is Nothing Then Set FromWorkbook = ActiveCodepaneWorkbook
    Dim procedures As Collection: Set procedures = LinkedProcs(PROCEDURENAME, FromWorkbook)
    On Error Resume Next
    procedures.Add PROCEDURENAME, PROCEDURENAME
    On Error GoTo 0
    Dim PROCEDURE As Variant
    Dim FileFullName As String
    Dim lastMod As Date
    Dim timeDif As Long
    
    For Each PROCEDURE In procedures
        FileFullName = SNIP_FOLDER & PROCEDURE & ".txt"

        If FileExists(FileFullName) = False Then
            Debug.Print IIf(FileExists(FileFullName) = False, "NEW ", "OVERWROTE ") & PROCEDURE
            TxtOverwrite FileFullName, GetProcText(ModuleOfProcedure(FromWorkbook, CStr(PROCEDURE)), CStr(PROCEDURE))
        Else
            On Error Resume Next
            lastMod = FileLastModified(FileFullName)
            timeDif = DateDiff("s", lastMod, Now())
            On Error GoTo 0
            If timeDif > 60 Then
                Debug.Print IIf(FileExists(FileFullName) = False, "NEW ", "OVERWROTE ") & PROCEDURE
                TxtOverwrite FileFullName, GetProcText(ModuleOfProcedure(FromWorkbook, CStr(PROCEDURE)), CStr(PROCEDURE))
            End If
        End If
    Next
    
End Sub

Private Function LinkedProcs( _
         PROCEDURENAME As Variant, _
         FromWorkbook As Workbook) As Collection
    Rem dp LinkedProcs("FindIfGetRow",thisworkbook)
'#INCLUDE GetCallsOfProcedure
'#INCLUDE ProceduresOfWorkbook
'#INCLUDE ModuleOfProcedure
'#INCLUDE dp
'#INCLUDE CollectionContains
    Dim AllProcedures As Collection:       Set AllProcedures = ProceduresOfWorkbook(FromWorkbook)
    Dim Proccessed As Collection:          Set Proccessed = New Collection
    Dim CalledProcedures As Collection:    Set CalledProcedures = New Collection
        GetCallsOfProcedure ModuleOfProcedure(FromWorkbook, PROCEDURENAME), PROCEDURENAME, AllProcedures, CalledProcedures
    Dim CalledProceduresCount As Long:    CalledProceduresCount = CalledProcedures.Count
    Dim PROCEDURE As Variant
    Dim Module As VBComponent
REPEAT:
    
    For Each PROCEDURE In CalledProcedures
            
        If Not CollectionContains(Proccessed, , CStr(PROCEDURE)) Then
            Proccessed.Add PROCEDURE, CStr(PROCEDURE)
            Set Module = ModuleOfProcedure(FromWorkbook, PROCEDURENAME)
            GetCallsOfProcedure Module, CStr(PROCEDURE), AllProcedures, CalledProcedures
        End If
    Next
    If CalledProcedures.Count > CalledProceduresCount Then
        CalledProceduresCount = CalledProcedures.Count
        GoTo REPEAT
    End If
    Set LinkedProcs = CalledProcedures
End Function

Private Function TxtRead(sPath As String) As String
'#INCLUDE FileExists
    If FileExists(sPath) = False Then
        MsgBox "File was not found."
        Exit Function
    End If
    Open sPath For Input As #1
    Do Until EOF(1)
        Line Input #1, sTXT
        TxtRead = TxtRead & sTXT & vbLf
    Loop
    Close
    If Len(TxtRead) = 0 Then
        TxtRead = ""
    Else
        TxtRead = Left(TxtRead, Len(TxtRead) - 1)
    End If
End Function


Private Function ProceduresOfWorkbook( _
                            TargetWorkbook As Workbook, _
                            Optional ExcludeDocument As Boolean = True, _
                            Optional ExcludeClass As Boolean = True, _
                            Optional ExcludeForm As Boolean = True) As Collection
                            
    Dim Module As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long
    Dim coll As New Collection
    Dim PROCEDURENAME As String
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If ExcludeClass = True Then
            If Module.Type = vbext_ct_ClassModule Then GoTo SKIP
        End If
        If ExcludeDocument = True Then
            If Module.Type = vbext_ct_Document Then GoTo SKIP
        End If
        If ExcludeForm = True Then
            If Module.Type = vbext_ct_MSForm Then GoTo SKIP
        End If
        
            If Module.Type <> vbext_ct_ClassModule Then
                With Module.CodeModule
                    lineNum = .CountOfDeclarationLines + 1
                    Do Until lineNum >= .CountOfLines
                        PROCEDURENAME = .ProcOfLine(lineNum, ProcKind)
                        If InStr(1, PROCEDURENAME, "_") = 0 Then coll.Add PROCEDURENAME
                        lineNum = .ProcStartLine(PROCEDURENAME, ProcKind) + .ProcCountLines(PROCEDURENAME, ProcKind) + 1
                    Loop
                End With
            End If
SKIP:
    Next Module
    Set ProceduresOfWorkbook = coll
End Function

Private Function ProcedureExists( _
         PROCEDURENAME As Variant, _
         FromWorkbook As Workbook) _
        As Boolean
'#INCLUDE ProceduresOfWorkbook
    Dim AllProcedures As Collection: Set AllProcedures = ProceduresOfWorkbook(FromWorkbook)
    Dim PROCEDURE As Variant
    For Each PROCEDURE In AllProcedures
        If UCase(CStr(PROCEDURE)) = UCase(PROCEDURENAME) Then
            ProcedureExists = True
            Exit Function
        End If
    Next
End Function

Private Function ActiveCodepaneWorkbook() As Workbook
    Dim TmpStr As String
    TmpStr = Application.VBE.SelectedVBComponent.Collection.Parent.FileName
    TmpStr = Right(TmpStr, Len(TmpStr) - InStrRev(TmpStr, "\"))
    Set ActiveCodepaneWorkbook = Workbooks(TmpStr)
End Function

Private Function ActiveProcedure() As String
    Application.VBE.ActiveCodePane.GetSelection L1&, C1&, L2&, C2&
    ActiveProcedure = Application.VBE.ActiveCodePane _
                     .CodeModule.ProcOfLine(L1&, vbext_pk_Proc)
End Function

Private Sub ListContainedProceduresInTXT(FileName As String)
'#INCLUDE ProceduresOfTXT
'#INCLUDE TxtOverwrite
'#INCLUDE TxtRead
    Dim v As Variant: v = ProceduresOfTXT(FileName, True)
    If TypeName(v) = "Empty" Then Exit Sub
    Dim s As String: s = TxtRead(FileName)
    Dim line As String: line = String(30, "'")
    TxtOverwrite FileName, _
    line & vbNewLine & _
    "'Contains the following procedures " & "#" & UBound(v) & vbNewLine & line & vbNewLine & "'" & _
    Join(v, vbNewLine & "'") & vbNewLine & vbNewLine & s
End Sub

Private Sub FollowLink(FolderPath As String)
    If Right(FolderPath, 1) = "\" Then FolderPath = Left(FolderPath, Len(FolderPath) - 1)
    On Error Resume Next
    Dim oShell As Object
    Dim Wnd As Object
    Set oShell = CreateObject("Shell.Application")
    For Each Wnd In oShell.Windows
        If Wnd.Name = "File Explorer" Then
            If Wnd.Document.Folder.Self.path = FolderPath Then Exit Sub
            
        End If
    Next Wnd
    Application.ThisWorkbook.FollowHyperlink Address:=FolderPath, NewWindow:=True
End Sub

Private Sub dp(var As Variant)
'#INCLUDE DPH
'#INCLUDE ArrayDimensions
    Dim ELEMENT As Variant
    Select Case TypeName(var)
        Case Is = "String", "Long", "Integer", "Boolean"
            Debug.Print var
        Case Is = "Variant()", "String()", "Long()", "Integer()"
            If ArrayDimensions(var) = 1 Then
                Dim i As Long
                For i = LBound(var) To UBound(var)
                    Debug.Print var(i)
                Next i
            ElseIf ArrayDimensions(var) > 1 Then
                DPH var
            End If
        Case Is = "Collection"
            For Each ELEMENT In var
                dp ELEMENT
            Next ELEMENT
        Case Is = "Range"
            dp var.Value
        Case Is = "Date"
            Debug.Print var
        Case Else
    End Select
End Sub

Private Function CollectionContains(Kollection As Collection, Optional Key As Variant, Optional Item As Variant) As Boolean
    Dim strKey As String
    Dim var As Variant
    If Not IsMissing(Key) Then
        strKey = CStr(Key)
        On Error Resume Next
        CollectionContains = True
        var = Kollection(strKey)
        If Err.Number = 91 Then GoTo CheckForObject
        If Err.Number = 5 Then GoTo NotFound
        On Error GoTo 0
        Exit Function
CheckForObject:
        If IsObject(Kollection(strKey)) Then
            CollectionContains = True
            On Error GoTo 0
            Exit Function
        End If
NotFound:
        CollectionContains = False
        On Error GoTo 0
        Exit Function
    ElseIf Not IsMissing(Item) Then
        CollectionContains = False
        For Each var In Kollection
            If var = Item Then
                CollectionContains = True
                Exit Function
            End If
        Next var
    Else
        CollectionContains = False
    End If
End Function

Private Function RegexTest( _
       ByVal string1 As String, _
       ByVal stringPattern As String, _
       Optional ByVal globalFlag As Boolean, _
       Optional ByVal ignoreCaseFlag As Boolean, _
       Optional ByVal multilineFlag As Boolean) _
        As Boolean
    Dim Regex As Object
    Set Regex = CreateObject("VBScript.RegExp")
    With Regex
        .Global = globalFlag
        .IgnoreCase = ignoreCaseFlag
        .MultiLine = multilineFlag
        .Pattern = stringPattern
    End With
    RegexTest = Regex.test(string1)
End Function

Private Function ProcedureFirstLine(Module As VBComponent, procname As String) As Long
'#INCLUDE InStrExact
    Dim N As Long
    Dim s As String
    Dim ProcKind As VBIDE.vbext_ProcKind
    For N = Module.CodeModule.ProcBodyLine(procname, ProcKind) + IIf(N = 0, 1, 0) To Module.CodeModule.CountOfLines
        s = Trim(Module.CodeModule.Lines(N, 1))
        If s = vbNullString Then
            Exit For
        ElseIf Left(s, 1) = "'" Then
        ElseIf Left(s, 3) = "Rem" Then
        ElseIf Right(Trim(Module.CodeModule.Lines(N - 1, 1)), 1) = "_" Then
        ElseIf Right(s, 1) = "_" Then
        ElseIf InStrExact(1, s, "Sub ") Then
        ElseIf InStrExact(1, s, "Function ") Then
        Else
            Exit For
        End If
    Next N
    ProcedureFirstLine = N
End Function

Private Function GetProcText(vbComp As VBComponent, _
                            sProcName As Variant, _
                            Optional bInclHeader As Boolean = True) As String
    If vbComp Is Nothing Then
        'sProcName not found
        Stop
    End If
    Dim codeMod As CodeModule
    Set codeMod = vbComp.CodeModule
    Dim lProcStart            As Long
    Dim lProcBodyStart        As Long
    Dim lProcNoLines          As Long
    Const vbext_pk_Proc = 0
    On Error GoTo Error_Handler
    lProcStart = codeMod.ProcStartLine(sProcName, vbext_pk_Proc)
    lProcBodyStart = codeMod.ProcBodyLine(sProcName, vbext_pk_Proc)
    lProcNoLines = codeMod.ProcCountLines(sProcName, vbext_pk_Proc)
    If bInclHeader = True Then
        GetProcText = codeMod.Lines(lProcStart, lProcNoLines)
    Else
        lProcNoLines = lProcNoLines - (lProcBodyStart - lProcStart)
        GetProcText = codeMod.Lines(lProcBodyStart, lProcNoLines)
    End If
Error_Handler_Exit:
    On Error Resume Next
    Exit Function
Error_Handler:
    Rem debug.Print _
    "Error Source: GetProcText" & vbCrLf & _
    "Error Description: " & err.Description & _
    Switch(Erl = 0, vbNullString, Erl <> 0, vbCrLf & "Line No: " & Erl)
    Resume Error_Handler_Exit
End Function

Private Function ModuleOfProcedure(wb As Workbook, PROCEDURENAME As Variant) As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long, NumProc As Long
    Dim procname As String
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        With vbComp.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines
                procname = .ProcOfLine(lineNum, ProcKind)
                lineNum = .ProcStartLine(procname, ProcKind) + .ProcCountLines(procname, ProcKind) + 1
                If UCase(procname) = UCase(PROCEDURENAME) Then
                    Set ModuleOfProcedure = vbComp
                    Exit Function
                End If
            Loop
        End With
    Next vbComp
End Function

Private Function FileLastModified(FilePath) As Date
    Dim fs, f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(FilePath)
    FileLastModified = f.DateLastModified
End Function


Private Sub GetCallsOfProcedure( _
                        Module As VBComponent, _
                        PROCEDURENAME As Variant, _
                        AllProcedures As Collection, _
                        ByRef OutputCollection As Collection)
'#INCLUDE ArrayTrim
'#INCLUDE GetProcText
'#INCLUDE InStrExact
    
    Dim Code As String: Code = GetProcText(Module, PROCEDURENAME)
    Dim CodeLines As Variant
    Dim PROCEDURE As Variant
    Dim CodeLine As Variant
    For Each PROCEDURE In AllProcedures
        If CStr(PROCEDURE) <> PROCEDURENAME Then
            If InStr(1, Code, CStr(PROCEDURE)) > 0 Then
                CodeLines = Split(Code, vbNewLine)
                ArrayTrim CodeLines
                For Each CodeLine In CodeLines
                    If InStrExact(1, CStr(CodeLine), CStr(PROCEDURE), True) > 0 Then
                        On Error Resume Next
                        OutputCollection.Add CStr(PROCEDURE), CStr(PROCEDURE)
                        On Error GoTo 0
                        Exit For
                    End If
                Next
            End If
        End If
    Next PROCEDURE
End Sub




Private Sub ArrayTrim(arr As Variant)
    Dim i As Long
    For i = LBound(arr) To UBound(arr)
        If TypeName(arr(i)) = "String" Then arr(i) = Trim(arr(i))
    Next
End Sub

Private Function InStrExact(Start As Long, SourceText As String, WordToFind As String, _
                    Optional CaseSensitive As Boolean = False, _
                    Optional AllowAccentedCharacters As Boolean = False) As Long
    Dim x As Long, Str1 As String, Str2 As String, Pattern As String
    Const UpperAccentsOnly As String = "???"
    Const UpperAndLowerAccents As String = "??????"
    If CaseSensitive Then
        Str1 = SourceText
        Str2 = WordToFind
        Pattern = "[!A-Za-z0-9]"
        If AllowAccentedCharacters Then Pattern = Replace(Pattern, "!", "!" & UpperAndLowerAccents)
    Else
        Str1 = UCase(SourceText)
        Str2 = UCase(WordToFind)
        Pattern = "[!A-Z0-9]"
        If AllowAccentedCharacters Then Pattern = Replace(Pattern, "!", "!" & UpperAccentsOnly)
    End If
    For x = Start To Len(Str1) - Len(Str2) + 1
        If Mid(" " & Str1 & " ", x, Len(Str2) + 2) Like Pattern & Str2 & Pattern _
                                                   And Not Mid(Str1, x) Like Str2 & "'[" & Mid(Pattern, 3) & "*" Then
            InStrExact = x
            Exit Function
        End If
    Next
End Function


Private Function ProceduresOfTXT(FilePath As Variant, Optional NameOnly As Boolean) As Variant
'#INCLUDE joinArrays
'#INCLUDE SortArray
'#INCLUDE TxtRead
    Dim var
    var = Split(TxtRead(CStr(FilePath)), Chr(10))
    Dim out
    out = joinArrays(Filter(var, "Sub "), Filter(var, "Function "))
    If TypeName(out) = "Empty" Then Exit Function
    out = Filter(out, "(", True)
    out = Filter(out, "Declare", False)
    out = Filter(out, Chr(34) & "Sub ", False)
    out = Filter(out, Chr(34) & "Function ", False)
    If NameOnly = True Then
        Dim i As Long
        For i = LBound(out) To UBound(out)
                out(i) = Left(out(i), InStr(1, out(i), "(") - 1)
                out(i) = Replace(out(i), "Private ", "")
                out(i) = Replace(out(i), "Public ", "")
                out(i) = Replace(out(i), "Sub ", "")
                out(i) = Replace(out(i), "Function ", "")
        Next
    End If
    out = SortArray(out)
    ProceduresOfTXT = out
    Rem ProceduresOfTXT = Join(out, Chr(10))
End Function


Private Function joinArrays(arr1 As Variant, arr2 As Variant) As Variant
    Dim arrToReturn() As Variant, myCollection As New Collection
    For Each x In arr1: myCollection.Add x: Next
    For Each y In arr2: myCollection.Add y: Next
    If myCollection.Count = 0 Then
        joinArrays = Array("")
        Exit Function
    End If
    ReDim arrToReturn(1 To myCollection.Count)
    For i = 1 To myCollection.Count: arrToReturn(i) = myCollection.Item(i): Next
    joinArrays = arrToReturn
End Function

Private Sub DPH(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional HairetuName$)
'#INCLUDE DebugPrintHairetu
    Call DebugPrintHairetu(Hairetu, HyoujiMaxNagasa, HairetuName)
End Sub

Private Function ArrayDimensions(ByVal vArray As Variant) As Long
    Dim dimnum As Long
    On Error GoTo FinalDimension
    For dimnum = 1 To 60000
        ErrorCheck = LBound(vArray, dimnum)
    Next
FinalDimension:
    ArrayDimensions = dimnum - 1
End Function

Rem ------------------------


Private Sub DebugPrintHairetu(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional HairetuName$)
'#INCLUDE ShortenToByteCharacters
    Dim i&, j&, k&, m&, N&
    Dim TateMin&, TateMax&, YokoMin&, YokoMax&
    Dim WithTableHairetu
    Dim NagasaList, MaxNagasaList
    Dim NagasaOnajiList
    Dim OutputList
    Const SikiriMoji$ = "|"
    Dim Jigen2%
    On Error Resume Next
    Jigen2 = UBound(Hairetu, 2)
    On Error GoTo 0
    If Jigen2 = 0 Then
        Hairetu = Application.Transpose(Hairetu)
    End If
    TateMin = LBound(Hairetu, 1)
    TateMax = UBound(Hairetu, 1)
    YokoMin = LBound(Hairetu, 2)
    YokoMax = UBound(Hairetu, 2)
    ReDim WithTableHairetu(1 To TateMax - TateMin + 1 + 1, 1 To YokoMax - YokoMin + 1 + 1)
    For i = 1 To TateMax - TateMin + 1
        WithTableHairetu(i + 1, 1) = TateMin + i - 1
            For j = 1 To YokoMax - YokoMin + 1
                WithTableHairetu(1, j + 1) = YokoMin + j - 1
                    WithTableHairetu(i + 1, j + 1) = Hairetu(i - 1 + TateMin, j - 1 + YokoMin)
                    Next j
                Next i
                N = UBound(WithTableHairetu, 1)
                m = UBound(WithTableHairetu, 2)
                ReDim NagasaList(1 To N, 1 To m)
                ReDim MaxNagasaList(1 To m)
                Dim TmpStr$
                For j = 1 To m
                    For i = 1 To N
                        If j > 1 And HyoujiMaxNagasa <> 0 Then
                            TmpStr = WithTableHairetu(i, j)
                            WithTableHairetu(i, j) = ShortenToByteCharacters(TmpStr, HyoujiMaxNagasa)
                            End If
                            NagasaList(i, j) = LenB(StrConv(WithTableHairetu(i, j), vbFromUnicode))
                            MaxNagasaList(j) = WorksheetFunction.Max(MaxNagasaList(j), NagasaList(i, j))
                        Next i
                    Next j
                    ReDim NagasaOnajiList(1 To N, 1 To m)
                    Dim TmpMaxNagasa&
                    For j = 1 To m
                        TmpMaxNagasa = MaxNagasaList(j)
                        For i = 1 To N
                            NagasaOnajiList(i, j) = WithTableHairetu(i, j) & WorksheetFunction.Rept(" ", TmpMaxNagasa - NagasaList(i, j))
                        Next i
                    Next j
                    ReDim OutputList(1 To N)
                    For i = 1 To N
                        For j = 1 To m
                            If j = 1 Then
                                OutputList(i) = NagasaOnajiList(i, j)
                            Else
                                OutputList(i) = OutputList(i) & SikiriMoji & NagasaOnajiList(i, j)
                            End If
                        Next j
                    Next i
                    Debug.Print HairetuName
                    For i = 1 To N
                        Debug.Print OutputList(i)
                    Next i
                End Sub

Private Function ShortenToByteCharacters(Mojiretu$, ByteNum%)
'#INCLUDE CalculateByteCharacters
'#INCLUDE TextDecomposition
    Dim OriginByte%
    Dim Output
    OriginByte = LenB(StrConv(Mojiretu, vbFromUnicode))
    If OriginByte <= ByteNum Then
        Output = Mojiretu
    Else
        Dim RuikeiByteList, BunkaiMojiretu
        RuikeiByteList = CalculateByteCharacters(Mojiretu)
        BunkaiMojiretu = TextDecomposition(Mojiretu)
        Dim AddMoji$
        AddMoji = "."
        Dim i&, N&
        N = Len(Mojiretu)
        For i = 1 To N
            If RuikeiByteList(i) < ByteNum Then
                Output = Output & BunkaiMojiretu(i)
            ElseIf RuikeiByteList(i) = ByteNum Then
                If LenB(StrConv(BunkaiMojiretu(i), vbFromUnicode)) = 1 Then
                    Output = Output & AddMoji
                Else
                    Output = Output & AddMoji & AddMoji
                End If
                Exit For
            ElseIf RuikeiByteList(i) > ByteNum Then
                Output = Output & AddMoji
                Exit For
            End If
        Next i
    End If
    ShortenToByteCharacters = Output
End Function

Private Function CalculateByteCharacters(Mojiretu$)
    Dim MojiKosu%
    MojiKosu = Len(Mojiretu)
    Dim Output
    ReDim Output(1 To MojiKosu)
    Dim i&
    Dim TmpMoji$
    For i = 1 To MojiKosu
        TmpMoji = Mid(Mojiretu, i, 1)
        If i = 1 Then
            Output(i) = LenB(StrConv(TmpMoji, vbFromUnicode))
        Else
            Output(i) = LenB(StrConv(TmpMoji, vbFromUnicode)) + Output(i - 1)
        End If
    Next i
    CalculateByteCharacters = Output
End Function

Private Function TextDecomposition(Mojiretu$)
    Dim i&, N&
    Dim Output
    N = Len(Mojiretu)
    ReDim Output(1 To N)
    For i = 1 To N
        Output(i) = Mid(Mojiretu, i, 1)
    Next i
    TextDecomposition = Output
End Function



Private Function CheckPath(path) As String
'#INCLUDE FileExists
'#INCLUDE FolderExists
'#INCLUDE HttpExists
    Dim retval
    retval = "I"
    If (retval = "I") And FileExists(path) Then retval = "F"
    If (retval = "I") And FolderExists(path) Then retval = "D"
    If (retval = "I") And HttpExists(path) Then retval = "U"
    CheckPath = retval
End Function

Private Function CodepaneSelection() As String
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    If EndLine - StartLine = 0 Then
        CodepaneSelection = Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(StartLine, 1), StartColumn, EndColumn - StartColumn)
        Exit Function
    End If
    Dim str As String
    Dim i As Long
    For i = StartLine To EndLine
        If str = "" Then
            str = Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), StartColumn)
        ElseIf i < EndLine Then
            str = str & vbNewLine & Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), 1)
        Else
            str = str & vbNewLine & Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), 1, EndColumn - 1)
        End If
    Next
    CodepaneSelection = str
End Function

Private Sub ImportImports( _
    Optional PROCEDURE As String, _
    Optional TargetWorkbook As Workbook, _
    Optional Module As VBComponent, _
    Optional OverWrite As Boolean)
'#INCLUDE ImportProcedure
'#INCLUDE TxtRead
    
    Rem @TODO infinite loop possible?
    Dim var
    Dim importfile As String
    var = Split(TxtRead(PROCEDURE), vbLf)
    Dim TextLine As Variant
    For Each TextLine In var
        TextLine = Trim(TextLine)
        If Left(TextLine, 9) = "'#INCLUDE" Then
            importfile = Split(TextLine, " ")(1)
            ImportProcedure importfile, TargetWorkbook, Module, OverWrite
        End If
    Next
End Sub

Private Sub UpdateProcedure( _
                            PROCEDURE As Variant, _
                            Code As String, _
                            TargetWorkbook As Workbook)
'#INCLUDE ModuleOfProcedure
    Dim StartLine As Integer
    Dim NumLines As Integer
    Dim Module As VBComponent
    Set Module = ModuleOfProcedure(TargetWorkbook, PROCEDURE)
    With Module.CodeModule
        StartLine = .ProcStartLine(PROCEDURE, vbext_pk_Proc)
        NumLines = .ProcCountLines(PROCEDURE, vbext_pk_Proc)
        .DeleteLines StartLine, NumLines
        .InsertLines StartLine, Code
    End With
End Sub

Private Function CreateOrSetModule(compName As String, compType As VBIDE.vbext_ComponentType, Optional TargetWorkbook As Workbook) As VBComponent
'#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim vbComp As VBComponent
    On Error Resume Next
    Set vbComp = TargetWorkbook.VBProject.VBComponents(compName)
    On Error GoTo 0
    If vbComp Is Nothing Then
        Set vbComp = TargetWorkbook.VBProject.VBComponents.Add(compType)
        vbComp.Name = compName
    End If
    Set CreateOrSetModule = vbComp
End Function

Private Function FolderExists(ByVal strPath As String) As Boolean
    On Error Resume Next
    FolderExists = ((GetAttr(strPath) And vbDirectory) = vbDirectory)
End Function

Private Function HttpExists(ByVal sURL As String) As Boolean
    Dim oXHTTP As Object
    Set oXHTTP = CreateObject("MSXML2.XMLHTTP")
    If Not UCase(sURL) Like "HTTP:*" Then
        sURL = "http://" & sURL
    End If
    On Error GoTo haveError
    oXHTTP.Open "HEAD", sURL, False
    oXHTTP.send
    HttpExists = IIf(oXHTTP.Status = 200, True, False)
    Exit Function
haveError:
    Rem Debug.Print err.Description
    HttpExists = False
End Function

Private Function SortArray(ByVal sortableArray As Variant, Optional ByVal descendingFlag As Boolean) As Variant
    '@Description: This function is an implementation of Bubble Sort, allowing the user to sort an array,
    '               optionally allowing the user to specify the array to be sorted in descending order
    '@Author: Anthony Mancini
    '@Version: 1.0.0
    '@License: MIT
    '@Param: sortableArray is the array that will be sorted
    '@Param: descendingFlag changes the sort to descending
    '@Returns: Returns the a sorted array
    '@Example: =Sort({1,3,2}) -> {1,2,3}
    '@Example: =Sort({1,3,2}, True) -> {3,2,1}
    Dim i As Integer
    Dim swapOccuredBool As Boolean
    Dim arrayLength As Integer
    arrayLength = UBound(sortableArray) - LBound(sortableArray) + 1
    Dim sortedArray() As Variant
    ReDim sortedArray(arrayLength)
    Dim dif As Long
    dif = IIf(LBound(sortableArray) = 1, 1, 0)
    For i = 0 To arrayLength - 1
        sortedArray(i) = sortableArray(i + dif)
    Next
    Dim temporaryValue As Variant
    Do
        swapOccuredBool = False
        For i = 0 To arrayLength - 1
            If (sortedArray(i)) < sortedArray(i + 1) Then
                temporaryValue = sortedArray(i)
                sortedArray(i) = sortedArray(i + 1)
                sortedArray(i + 1) = temporaryValue
                swapOccuredBool = True
            End If
        Next
    Loop While swapOccuredBool
    If descendingFlag = True Then
        SortArray = sortedArray
    Else
        Dim ascendingArray() As Variant
        ReDim ascendingArray(arrayLength)
        For i = 0 To arrayLength - 1
            ascendingArray(i) = sortedArray(arrayLength - i - 1)
        Next
        SortArray = ascendingArray
    End If
End Function

Private Sub FoldersCreate(FolderPath As String)
    Dim individualFolders() As String
    Dim tempFolderPath As String
    Dim arrayElement As Variant
    If Right(FolderPath, 1) = "\" Then FolderPath = Left(FolderPath, Len(FolderPath) - 1)
    individualFolders = Split(FolderPath, "\")
    On Error Resume Next
    For Each arrayElement In individualFolders
        tempFolderPath = tempFolderPath & arrayElement & "\"
        If Dir(tempFolderPath, vbDirectory) = "" Then
            MkDir tempFolderPath
        End If
    Next arrayElement
End Sub

